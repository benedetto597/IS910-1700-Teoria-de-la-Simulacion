package main

import (
	"bufio"
	"fmt"
	"log"
	"math/rand"
	"os"
	"strings"
	"time"

	"github.com/streadway/amqp"
	"rsc.io/quote"
)

type Resourse struct {
	id     int
	Name   string
	status bool
}

func main() {
	connection, err := amqp.Dial("amqp://guest:guest@localhost:5672/")
	if err != nil {
		log.Fatalf("%s: %s", "Error connecting to RabbitMQ", err)
	}
	defer connection.Close()

	channel, err := connection.Channel()
	if err != nil {
		log.Fatalf("%s: %s", "Error connecting to the channel", err)
	}
	defer channel.Close()

	// Create a queue
	queue, err := channel.QueueDeclare(
		"Resourse", // name of the queue
		false,      // durable or persistent
		false,      // delete when is used
		false,      // exclusive
		false,      // timeout
		nil,        // arguments
	)

	if err != nil {
		log.Fatalf("%s: %s", "Error creating the queue", err)
	}

	// Select type of message to send
	menu :=
		`
	Welcome to the RabbitMQ Producer
	[ 1 ] Manual message
	[ 2 ] Autogenerated messages
	[ 3 ] Now time messages
	[ 4 ] Insert resourse
	Â¿Which one do you want to send?
`
	fmt.Print(menu)
	reader := bufio.NewReader(os.Stdin)

	entry, _ := reader.ReadString('\n')
	choose := strings.TrimRight(entry, "\r\n") // Remove \n and \r

	switch choose {
	case "1":
		// Get the message from the user
		scanner := bufio.NewScanner(os.Stdin)
		fmt.Println("Type your message and press enter to send it to the queue")
		scanner.Scan()
		message := scanner.Text()
		err = channel.Publish(
			"",         // exchange
			queue.Name, // routing key
			false,      // mandatory
			false,      // immediate
			amqp.Publishing{
				ContentType: "text/plain",
				Body:        []byte(message), // message body parsed as byte array
			})
		if err != nil {
			log.Fatalf("%s: %s", "Error sending the message", err)
		}
		log.Printf("\n%s: %s", "Message sent", message)
	case "2":
		// Generate message from quote package
		quote1, quote2, quote3 := quote.Go(), quote.Glass(), quote.Opt()
		var quotes [3]string

		quotes[0] = quote1
		quotes[1] = quote2
		quotes[2] = quote3

		for {
			random := rand.Intn(3)
			message := quotes[random]
			err = channel.Publish(
				"",         // exchange
				queue.Name, // routing key
				false,      // mandatory
				false,      // immediate
				amqp.Publishing{
					ContentType: "text/plain",
					Body:        []byte(message), // message body parsed as byte array
				})

			if err != nil {
				log.Fatalf("%s: %s", "Error sending the message", err)
				break
			}

			log.Printf("\n%s: %s", "Message sent", message)
			time.Sleep(5 * time.Second)
		}

	case "3":
		// Message of current time
		for {
			message := time.Now().String()
			err = channel.Publish(
				"",         // exchange
				queue.Name, // routing key
				false,      // mandatory
				false,      // immediate
				amqp.Publishing{
					ContentType: "text/plain",
					Body:        []byte(message), // message body parsed as byte array
				})

			if err != nil {
				log.Fatalf("%s: %s", "Error sending the message", err)
				break
			}

			log.Printf("\n%s: %s", "Message sent", message)
			time.Sleep(5 * time.Second)
		}
	case "4":
		// Insert resourse
		for {

			resourse := Resourse{
				id:     rand.Intn(100),
				Name:   "Resourse",
				status: true,
			}
			message := resourse.Name + " " + string(resourse.id)
			err = channel.Publish(
				"",         // exchange
				queue.Name, // routing key
				false,      // mandatory
				false,      // immediate
				amqp.Publishing{
					ContentType: "text/plain",
					Body:        []byte(message), // message body parsed as byte array
				})

			if err != nil {
				log.Fatalf("%s: %s", "Error sending the message", err)
				break
			}

			log.Printf("\n%s: %s", "Message sent", message)
			time.Sleep(5 * time.Second)
		}

	default:
		log.Fatalf("You did not choose a valid option")
	}

}
